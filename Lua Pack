--Hitbox Hit Draw

local UI_REF = gui.Reference( "VISUALS", "ENEMIES", "Options" );

local DrawHitboxHitText = gui.Text( UI_REF, "Draw Hitbox Hit");
local DrawHitboxHit = gui.Checkbox( UI_REF, "lua_drawhitboxhit", "Draw", 0 );
local HitboxDrawTime = gui.Slider( UI_REF, "lua_drawhitboxhit_time", "Draw Time in Seconds", 2, 1, 10 );
local HitboxDrawSize= gui.Slider( UI_REF, "lua_drawhitboxhit_size", "Draw Size", 6, 1, 25 ); 

local text_font = draw.CreateFont("Verdana", 12, 400);

local hitboxes = {};
local hitbox_text = {};
local ticks = {};

local function HitGroup( INT_HITGROUP )
  if INT_HITGROUP == 0 then
      return "body";
  elseif INT_HITGROUP == 1 then
      return "head";
  elseif INT_HITGROUP == 2 then
      return "chest";
  elseif INT_HITGROUP == 3 then
      return "stomach";
  elseif INT_HITGROUP == 4 then 
      return "left arm";
  elseif INT_HITGROUP == 5 then 
      return "right arm";
  elseif INT_HITGROUP == 6 then 
      return "left leg";
  elseif INT_HITGROUP == 7 then 
      return "right leg";
  elseif INT_HITGROUP == 8 then 
        return "hitbox 8";
  elseif INT_HITGROUP == 9 then 
     return "hitbox 9";
  elseif INT_HITGROUP == 10 then 
      return "body";
  end
end

local function on_player_death(e)
  if (e:GetName() == "player_hurt" and DrawHitboxHit:GetValue()) then
     local ENTITY_LOCAL_PLAYER = client.GetLocalPlayerIndex();
  
     local ID_VICTIM, ID_ATTACKER, HITGROUP, BONE = e:GetInt("userid"), e:GetInt("attacker"), e:GetInt("hitgroup"),  e:GetInt("boneIndex");
     local INDEX_VICTIM, INDEX_ATTACKER = client.GetPlayerIndexByUserID(ID_VICTIM), client.GetPlayerIndexByUserID(ID_ATTACKER);
  
     if (INDEX_ATTACKER == ENTITY_LOCAL_PLAYER and INDEX_VICTIM ~= ENTITY_LOCAL_PLAYER) then

        local ENEMY = entities.GetByUserID(ID_VICTIM);
        local HITBOX_POS = {ENEMY:GetHitboxPosition(HITGROUP)};
        local HIT_TEXT = HitGroup(HITGROUP);

        if(HITBOX_POS ~= nil) then
           table.insert(hitboxes, HITBOX_POS);
           table.insert(hitbox_text, HIT_TEXT);
           table.insert(ticks, common.Time());
        end
     end
  end
end

local function render_hitpos()
  local player = entities.GetLocalPlayer();

  if DrawHitboxHit:GetValue() and player ~= nil and player:IsAlive() then
     for index = 1, #hitboxes do
        if (hitboxes[index] ~= nil and
           ticks[index] ~= nil) then

           local HITBOX = hitboxes[index];
           local screen_x, screen_y = client.WorldToScreen(HITBOX[1], HITBOX[2], HITBOX[3]);

           if(screen_x ~= nil and screen_y ~= nil) then
              local drawSize = HitboxDrawSize:GetValue() / 2;
              draw.Color(255, 0, 0, 255);
              draw.FilledRect(screen_x - drawSize, screen_y - drawSize, screen_x + drawSize, screen_y + drawSize);
              draw.Color(0, 0, 0, 255);
              draw.OutlinedRect(screen_x - drawSize, screen_y - drawSize, screen_x + drawSize, screen_y + drawSize);
              draw.Color(255, 255, 255, 255);
              draw.SetFont(text_font);
              local text_size_x, text_size_y = draw.GetTextSize(hitbox_text[index]);
              draw.Text(screen_x - text_size_x/2, screen_y + drawSize*0.8, hitbox_text[index] );
              draw.TextShadow(screen_x - text_size_x/2, screen_y + drawSize*0.8, hitbox_text[index] );



              local tick_difference = common.Time() - ticks[index];

              if (tick_difference > HitboxDrawTime:GetValue()) then
                 table.remove(hitboxes, index);
                 table.remove(hitbox_text, index);
                 table.remove(ticks, index);
              end
           else
              table.remove(hitboxes, index);
              table.remove(hitbox_text, index);
              table.remove(ticks, index);
           end
        end
     end
  end
end

callbacks.Register( "Draw", "render_hitpos", render_hitpos);

client.AllowListener("player_hurt");
callbacks.Register("FireGameEvent", "HS_SOUND", on_player_death);



--Disablepostprocessing

local VIS_MAIN_REF = gui.Reference( "MISC", "GENERAL", "Extra" );

local DisablePostProcessing = gui.Checkbox( VIS_MAIN_REF, "lua_disablepostprocess", "Disable Post Processing", 0 );

local function PostProcessing()

	if DisablePostProcessing:GetValue() then
		client.SetConVar( "mat_postprocess_enable", 0, true );
	else
		client.SetConVar( "mat_postprocess_enable", 1, true );
	end

end

callbacks.Register( "Draw", "Disable Post Processing", PostProcessing )



--Sniper Crosshair

local VIS_MAIN_REF = gui.Reference( "VISUALS", "Shared" );

local SniperCrosshairCheckbox = gui.Checkbox( VIS_MAIN_REF, "lua_snipercrosshair", "Sniper Crosshair", 0 );

local function SniperCrosshair()

	if SniperCrosshairCheckbox:GetValue() then
		if entities.GetLocalPlayer() ~= nil then
			local LocalPlayerEntity = entities.GetLocalPlayer();

			local Alive = LocalPlayerEntity:IsAlive();			
			local isScoped = LocalPlayerEntity:GetPropInt( "m_bIsScoped" );
	
			local Thirdperson = gui.GetValue( "vis_thirdperson_dist" );
			local Scoperemover = gui.GetValue( "vis_scoperemover" );

			if Alive then
				if Scoperemover ~= 1 then
					if ( isScoped == 1 or isScoped == 257 or Thirdperson > 0 ) then
						client.SetConVar( "weapon_debug_spread_show", 0, true );
					else
						client.SetConVar( "weapon_debug_spread_show", 3, true );
					end
				elseif Scoperemover == 1 then
					if ( Thirdperson > 0 and isScoped == 0 or isScoped == 257 ) then
						client.SetConVar( "weapon_debug_spread_show", 0, true );
					else
						client.SetConVar( "weapon_debug_spread_show", 3, true );
					end
				end
			else
				client.SetConVar( "weapon_debug_spread_show", 0, true );
			end
		end
	else
		client.SetConVar( "weapon_debug_spread_show", 0, true );
	end

end

callbacks.Register( "Draw", "Sniper Crosshair", SniperCrosshair )



--Viewmodel changer 

local xO = 0;   local yO = 0;   local zO = 0;   local fO = 0;   
local function cache()   xO = client.GetConVar("viewmodel_offset_x");   yO = client.GetConVar("viewmodel_offset_y");   zO = client.GetConVar("viewmodel_offset_z");   fO = client.GetConVar("viewmodel_fov");   end cache()
local visref = gui.Reference("SETTINGS", "Miscellaneous");  
local wind = gui.Window("wind", "Viewmodel Extender", 200,200,200,270);
local gr = gui.Groupbox(wind, "Viewmodel Stuff", 10,10, 180,218)
local c = gui.Checkbox(visref, "c", "Show Viewmodel Extender", false)
local xS = gui.Slider(gr, "xS", "X", xO, -20, 20);   
local yS = gui.Slider(gr, "yS", "Y", yO, -100, 100);   
local zS = gui.Slider(gr, "zS", "Z", zO, -20, 20);   
local vfov = gui.Slider(gr, "vfov", "Viewmodel FOV", fO, 0, 120);   

function doesthing()
if c:GetValue() then wind:SetActive(1); else wind:SetActive(0); end
client.SetConVar("viewmodel_offset_x", xS:GetValue(), true); 
client.SetConVar("viewmodel_offset_y", yS:GetValue(), true); 
client.SetConVar("viewmodel_offset_z", zS:GetValue(), true); 
client.SetConVar("viewmodel_fov", vfov:GetValue(), true); end
callbacks.Register("Draw", "sets", doesthing);



--Quickpeek

local font_main = draw.CreateFont("Tahoma Bold", 20, 20)
local font_main_small = draw.CreateFont("Tahoma Bold", 13, 13)
-- Script 
local cur_scriptname = GetScriptName()
local cur_version = "1.2"
local git_version = "https://raw.githubusercontent.com/itisluiz/aimware_quickpeek/master/version.txt"
local git_repository = "https://raw.githubusercontent.com/itisluiz/aimware_quickpeek/master/quickpeek.lua"

-- UI Elements --
local ref_vis_msc_assistance = gui.Reference("VISUALS", "MISC", "Assistance")

local ref_rbot_shared = gui.Reference("RAGE", "WEAPON", "SHARED", "Accuracy")
local ref_rbot_pistol = gui.Reference("RAGE", "WEAPON", "PISTOL", "Accuracy")
local ref_rbot_revolver = gui.Reference("RAGE", "WEAPON", "REVOLVER", "Accuracy")
local ref_rbot_smg = gui.Reference("RAGE", "WEAPON", "SMG", "Accuracy")
local ref_rbot_rifle = gui.Reference("RAGE", "WEAPON", "RIFLE", "Accuracy")
local ref_rbot_shotgun = gui.Reference("RAGE", "WEAPON", "SHOTGUN", "Accuracy")
local ref_rbot_scout = gui.Reference("RAGE", "WEAPON", "SCOUT", "Accuracy")
local ref_rbot_autosniper = gui.Reference("RAGE", "WEAPON", "A. SNIPER", "Accuracy")
local ref_rbot_sniper = gui.Reference("RAGE", "WEAPON", "SNIPER", "Accuracy")
local ref_rbot_lmg = gui.Reference("RAGE", "WEAPON", "LMG", "Accuracy")

local cob_quickpeek_indicator = gui.Combobox(ref_vis_msc_assistance, "msc_quickpeek_indicator", "Quick Peek Indication", "Off", "On World", "On HUD", "On Both")
local cob_quickpeek_indicator_detail = gui.Combobox(ref_vis_msc_assistance, "msc_quickpeek_indicator", "Quick Peek Indication Style", "Fancy", "Simplified")

local key_shared_quickpeek = gui.Keybox(ref_rbot_shared, "rbot_shared_quickpeek_key", "Quick Peek Key", 0)
local sl_shared_quickpeek_returnaftershots = gui.Slider(ref_rbot_shared, "rbot_shared_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 15 )
local chb_shared_quickpeek_knife = gui.Checkbox(ref_rbot_shared, "rbot_shared_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_pistol_quickpeek = gui.Keybox(ref_rbot_pistol, "rbot_pistol_quickpeek_key", "Quick Peek Key", 0)
local sl_pistol_quickpeek_returnaftershots = gui.Slider(ref_rbot_pistol, "rbot_pistol_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 15 )
local chb_pistol_quickpeek_knife = gui.Checkbox(ref_rbot_pistol, "rbot_pistol_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_revolver_quickpeek = gui.Keybox(ref_rbot_revolver, "rbot_revolver_quickpeek_key", "Quick Peek Key", 0)
local sl_revolver_quickpeek_returnaftershots = gui.Slider(ref_rbot_revolver, "rbot_revolver_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 8 )
local chb_revolver_quickpeek_knife = gui.Checkbox(ref_rbot_revolver, "rbot_revolver_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_smg_quickpeek = gui.Keybox(ref_rbot_smg, "rbot_smg_quickpeek_key", "Quick Peek Key", 0)
local sl_smg_quickpeek_returnaftershots = gui.Slider(ref_rbot_smg, "rbot_smg_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 15 )
local chb_smg_quickpeek_knife = gui.Checkbox(ref_rbot_smg, "rbot_smg_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_rifle_quickpeek = gui.Keybox(ref_rbot_rifle, "rbot_rifle_quickpeek_key", "Quick Peek Key", 0)
local sl_rifle_quickpeek_returnaftershots = gui.Slider(ref_rbot_rifle, "rbot_rifle_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 15 )
local chb_rifle_quickpeek_knife = gui.Checkbox(ref_rbot_rifle, "rbot_rifle_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_shotgun_quickpeek = gui.Keybox(ref_rbot_shotgun, "rbot_shotgun_quickpeek_key", "Quick Peek Key", 0)
local sl_shotgun_quickpeek_returnaftershots = gui.Slider(ref_rbot_shotgun, "rbot_shotgun_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 8 )
local chb_shotgun_quickpeek_knife = gui.Checkbox(ref_rbot_shotgun, "rbot_shotgun_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_scout_quickpeek = gui.Keybox(ref_rbot_scout, "rbot_scout_quickpeek_key", "Quick Peek Key", 0)
local sl_scout_quickpeek_returnaftershots = gui.Slider(ref_rbot_scout, "rbot_scout_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 10 )
local chb_scout_quickpeek_knife = gui.Checkbox(ref_rbot_scout, "rbot_scout_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_autosniper_quickpeek = gui.Keybox(ref_rbot_autosniper, "rbot_autosniper_quickpeek_key", "Quick Peek Key", 0)
local sl_autosniper_quickpeek_returnaftershots = gui.Slider(ref_rbot_autosniper, "rbot_autosniper_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 15 )
local chb_autosniper_quickpeek_knife = gui.Checkbox(ref_rbot_autosniper, "rbot_autosniper_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_sniper_quickpeek = gui.Keybox(ref_rbot_sniper, "rbot_sniper_quickpeek_key", "Quick Peek Key", 0)
local sl_sniper_quickpeek_returnaftershots = gui.Slider(ref_rbot_sniper, "rbot_sniper_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 10 )
local chb_sniper_quickpeek_knife = gui.Checkbox(ref_rbot_sniper, "rbot_sniper_quickpeek_knife", "Quick Peek Switch to Knife", 1)

local key_lmg_quickpeek = gui.Keybox(ref_rbot_lmg, "rbot_lmg_quickpeek_key", "Quick Peek Key", 0)
local sl_lmg_quickpeek_returnaftershots = gui.Slider(ref_rbot_lmg, "rbot_lmg_quickpeek_returnaftershots", "Return After X Shots", 1, 1, 10 )
local chb_lmg_quickpeek_knife = gui.Checkbox(ref_rbot_lmg, "rbot_lmg_quickpeek_knife", "Quick Peek Switch to Knife", 1)


-- Check for updates
local function git_update()
	if cur_version ~= http.Get(git_version) then
		local this_script = file.Open(cur_scriptname, "w")
		this_script:Write(http.Get(git_repository))
		this_script:Close()
		print("[Lua Scripting] " .. cur_scriptname .. " has updated itself from version " .. cur_version .. " to " .. http.Get(git_version))
		print("[Lua Scripting] Please reload " .. cur_scriptname)
	else
		print("[Lua Scripting] " .. cur_scriptname .. " is up-to-date")
	end
end

local function drawCircle(Position, Radius)

    for degrees = 1, 360, 1 do
        local thisPoint = nil;
        local lastPoint = nil;
                
        if Position[3] == nil then
            thisPoint = {Position[1] + math.sin(math.rad(degrees)) * Radius, Position[2] + math.cos(math.rad(degrees)) * Radius};	
            lastPoint = {Position[1] + math.sin(math.rad(degrees - 1)) * Radius, Position[2] + math.cos(math.rad(degrees - 1)) * Radius};
        else
            thisPoint = {client.WorldToScreen(Position[1] + math.sin(math.rad(degrees)) * Radius, Position[2] + math.cos(math.rad(degrees)) * Radius, Position[3])};
            lastPoint = {client.WorldToScreen(Position[1] + math.sin(math.rad(degrees - 1)) * Radius, Position[2] + math.cos(math.rad(degrees - 1)) * Radius, Position[3])};
        end
                     
        if thisPoint[1] ~= nil and thisPoint[2] ~= nil and lastPoint[1] ~= nil and lastPoint[2] ~= nil then		
            draw.Line(thisPoint[1], thisPoint[2], lastPoint[1], lastPoint[2]);		
        end
        
    end

end

local function ActiveWeaponInfo(Entity)
    
    local ent_weapon = Entity:GetPropEntity("m_hActiveWeapon")

    if ent_weapon == nil then
        return nil
    end

    local str_weapon = ent_weapon:GetName()

    if string.find(str_weapon, "revolver") then
        return "revolver", 2 
    end
    if string.find(str_weapon, "ssg08") then
        return "scout", 1 
    end
    if string.find(str_weapon, "awp") then
        return "sniper", 1 
    end
    if string.find(str_weapon, "scar20") or string.find(str_weapon, "g3sg1") then
        return "autosniper", 1 
    end

    local type_weapon = Entity:GetWeaponType()

    if type_weapon == 0 then
        return nil
    end

    if type_weapon == 1 then
        return "pistol", 2
    end
    if type_weapon == 2 then
        return "smg", 1
    end
    if type_weapon == 3 then
        return "rifle", 1
    end
    if type_weapon == 4 then
        return "shotgun", 1
    end
	if type_weapon == 6 then
        return "lmg", 1
    end

    return nil
end

-- Global Variables ---
local msc_peekReturning = false
local msc_quickPeeking = false
local msc_peekCompleted = false

local start_ammo = 0
local cur_ammo = 0

local pos_peekOrigin = {}
local wpninfo_peek = nil
local startwpn_peek = nil
local curwpn_peek = nil

local cacheArray = 
{
    {"autostop", 0},
    {"autostop_key", 0}
}
-----------------------

local function ResetPeek()
    if msc_quickPeeking or msc_peekReturning or msc_peekCompleted then
        msc_quickPeeking = false
        msc_peekReturning = false
        msc_peekCompleted = false
        cur_ammo = 0
        start_ammo = 0

        for i = 1, #cacheArray do
            gui.SetValue("rbot_" .. wpninfo_peek[1] .. "_" .. cacheArray[i][1], cacheArray[i][2])
        end

        wpninfo_peek = nil
        startwpn_peek = nil
    end
end

local function DrawingCallback()
   
    local LocalPlayer = entities.GetLocalPlayer()
    
    -- Local player null and alive check
    if LocalPlayer == nil or not LocalPlayer:IsAlive() then
        ResetPeek()
        return
    end

    local pos_LocalPlayer = {LocalPlayer:GetAbsOrigin()}

    -- If weapon isn't a knife
    if LocalPlayer:GetWeaponType() ~= 0 then
        wpninfo_peek = {ActiveWeaponInfo(LocalPlayer)}
        curwpn_peek = LocalPlayer:GetWeaponID()
    end

    -- Check if array is null
    if wpninfo_peek == nil then
        return
    end

    -- Check if weapon is null
    if wpninfo_peek[1] == nil then
        return
    end

    -- If shared weapon configuration
    if gui.GetValue("rbot_sharedweaponcfg") then
        wpninfo_peek[1] = "shared"
    end

    -- Round Sliders
    if gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_returnaftershots") % 1 > 0 then
        gui.SetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_returnaftershots", math.floor(gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_returnaftershots") + 0.5))
    end

    -- Check if key is set
    if gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_key") == nil or gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_key") <= 0 then
        return
    end

    if input.IsButtonDown(gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_key")) and (startwpn_peek == curwpn_peek or startwpn_peek == nil) and start_ammo >= cur_ammo then
        if LocalPlayer:GetWeaponType() ~= 0 then
            cur_ammo = LocalPlayer:GetPropEntity("m_hActiveWeapon"):GetPropInt("m_iClip1")
        end

        if not msc_quickPeeking and LocalPlayer:GetWeaponType() ~= 0 then      
            
            msc_quickPeeking = true
            startwpn_peek = curwpn_peek  
            start_ammo = cur_ammo
            pos_peekOrigin = pos_LocalPlayer

            for i = 1, #cacheArray do
                cacheArray[i][2] = gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_" .. cacheArray[i][1])
            end

            gui.SetValue("rbot_" .. wpninfo_peek[1] .. "_" .. cacheArray[1][1], 1)
            gui.SetValue("rbot_" .. wpninfo_peek[1] .. "_" .. cacheArray[2][1], 0)
        elseif not msc_quickPeeking and LocalPlayer:GetWeaponType() == 0 then
            return
        end

        if msc_peekCompleted then
            msc_peekCompleted = false
            start_ammo = cur_ammo
            
            if gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_knife") then
                client.Command("slot" .. wpninfo_peek[2], true)
            end
        end

        if cur_ammo + gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_returnaftershots") <= start_ammo and not msc_peekReturning then
            msc_peekReturning = true

            if gui.GetValue("rbot_" .. wpninfo_peek[1] .. "_quickpeek_knife") then
                client.Command("slot3", true)
            end
        end
        
        local world_forward = {vector.Subtract( pos_peekOrigin,  pos_LocalPlayer )}
        local world_angles = {vector.Angles(world_forward)}
        
        local world_linestart = {pos_peekOrigin[1] - 9 * math.cos(math.rad(world_angles[2])), pos_peekOrigin[2] - 9 * math.sin(math.rad(world_angles[2])), pos_peekOrigin[3]}
        local world_lineend = {pos_LocalPlayer[1] + 5 * math.cos(math.rad(world_angles[2])), pos_LocalPlayer[2] + 5 * math.sin(math.rad(world_angles[2])), pos_LocalPlayer[3]}
        
        local wts_peekOrigin = {client.WorldToScreen(pos_peekOrigin[1], pos_peekOrigin[2], pos_peekOrigin[3])}
        local wts_peekOriginText = {client.WorldToScreen(pos_peekOrigin[1], pos_peekOrigin[2], pos_peekOrigin[3] + 20)}
        local wts_LocalPlayer = {client.WorldToScreen(pos_LocalPlayer[1], pos_LocalPlayer[2], pos_LocalPlayer[3])}

        local peek_distance = math.floor(vector.Distance(pos_peekOrigin, pos_LocalPlayer) + 0.5)
        local str_Indicator = "Quick Peeking: " .. peek_distance .. " units"
        local size_strIndicator
        
        if msc_peekReturning then
            str_Indicator = "Quick Returning: " .. peek_distance .. " units"
        end

        if (cob_quickpeek_indicator:GetValue() == 1 or cob_quickpeek_indicator:GetValue() == 3) and (wts_peekOrigin[1] ~= nil and wts_peekOriginText[1] ~= nil and wts_LocalPlayer[1] ~= nil) then
            draw.SetFont(font_main_small)
            size_strIndicator = {draw.GetTextSize(str_Indicator)}
            draw.Color(gui.GetValue("clr_gui_window_header_tab2"))
            if cob_quickpeek_indicator_detail:GetValue() == 0 then
                drawCircle(pos_peekOrigin, 10)
                drawCircle(pos_peekOrigin, 8)
                drawCircle(pos_LocalPlayer, 6)
                drawCircle(pos_LocalPlayer, 4)
                draw.Color(255, 255, 255, 255)
                drawCircle(pos_peekOrigin, 9)
                drawCircle(pos_LocalPlayer, 5)
            end
            draw.Color(255, 255, 255, 255)
            draw.TextShadow(wts_peekOriginText[1] - size_strIndicator[1] / 2, wts_peekOriginText[2], str_Indicator)

            local wts_linestart = {client.WorldToScreen(world_linestart[1], world_linestart[2], world_linestart[3])}
            local wts_lineend = {client.WorldToScreen(world_lineend[1], world_lineend[2], world_lineend[3])}

            if msc_peekReturning then
                draw.Color(gui.GetValue("clr_gui_window_header_tab2"))
            else
                draw.Color(255, 255, 255, 255)
            end

            if wts_linestart[1] ~= nil and wts_lineend[1] ~= nil and peek_distance > 15 then
                draw.Line(wts_linestart[1], wts_linestart[2], wts_lineend[1], wts_lineend[2])
            end

        end

        if cob_quickpeek_indicator:GetValue() >= 2 then
            local width_screen, height_screen = draw.GetScreenSize()
            draw.SetFont(font_main)
            size_strIndicator = {draw.GetTextSize(str_Indicator)}
            
            if cob_quickpeek_indicator_detail:GetValue() == 0 then
                draw.Color(0, 0, 0, 125)
                draw.FilledRect( width_screen / 2  - size_strIndicator[1] / 2, height_screen * 0.95 - size_strIndicator[2] / 2, width_screen / 2 + size_strIndicator[1] / 2, height_screen * 0.95 + size_strIndicator[2] / 2 ) 
                draw.Color(gui.GetValue("clr_gui_window_header_tab2"))
                draw.Line(width_screen / 2  - size_strIndicator[1] / 2, height_screen * 0.95 - size_strIndicator[2] / 2, width_screen / 2 + size_strIndicator[1] / 2, height_screen * 0.95 - size_strIndicator[2] / 2)
            end
            
            draw.Color(255, 255, 255, 255)
            draw.Text(width_screen / 2 - size_strIndicator[1] / 2, height_screen * 0.95 - size_strIndicator[2] / 2, str_Indicator)
        end
    
    else
        ResetPeek()
    end

end

local function CreateMoveCallback(UserCmd)

    if msc_peekReturning then
        local LocalPlayer = entities.GetLocalPlayer()    
        local ang_LocalPlayer = {UserCmd:GetViewAngles()}
        local world_forward = {vector.Subtract( pos_peekOrigin,  {LocalPlayer:GetAbsOrigin()} )}

        UserCmd:SetForwardMove( ( (math.sin(math.rad(ang_LocalPlayer[2]) ) * world_forward[2]) + (math.cos(math.rad(ang_LocalPlayer[2]) ) * world_forward[1]) ) * 200 )
        UserCmd:SetSideMove( ( (math.cos(math.rad(ang_LocalPlayer[2]) ) * -world_forward[2]) + (math.sin(math.rad(ang_LocalPlayer[2]) ) * world_forward[1]) ) * 200 )
        
        if vector.Length(world_forward) < 10 then
            msc_peekReturning = false
            msc_peekCompleted = true
        end
    end

end

if gui.GetValue("lua_allow_http") and gui.GetValue("lua_allow_cfg") then
	git_update()
else
	print("[Lua Scripting] Please enable Lua HTTP and Lua script/config editing to check for updates")
end

callbacks.Register("Draw", DrawingCallback)
callbacks.Register("CreateMove", CreateMoveCallback)



-- Grenade timers by Nyanpasu! (- Luiz)

local updatetick = 0;
local grenades = {};

function EventHook(Event)
-- Clean table on round start
if Event:GetName() == "round_start" then
grenades = {};
end
-- Remove expired grenades from Table
if Event:GetName() == "hegrenade_detonate" or Event:GetName() == "flashbang_detonate" 
or Event:GetName() == "inferno_expire" or Event:GetName() == "inferno_extinguish" then 
updatetick = globals.TickCount(); 
for index,value in pairs(grenades) do 
if value[1] == Event:GetInt("entityid") then
table.remove(grenades, index);
end
end 
end
end

function ESPHook(Builder)
-- Smoke Grenades
if Builder:GetEntity():GetClass() == "CSmokeGrenadeProjectile" 
and Builder:GetEntity():GetProp("m_nSmokeEffectTickBegin") ~= 0 then
delta = (globals.TickCount() - Builder:GetEntity():GetProp("m_nSmokeEffectTickBegin")) * globals.TickInterval();
Builder:AddBarBottom( 1 - (delta/17.5) )
-- Flash and HE Grenades
elseif Builder:GetEntity():GetClass() == "CBaseCSGrenadeProjectile" then
local found = false;
for index,value in pairs(grenades) do
if value[1] == Builder:GetEntity():GetIndex() then
DeltaT = (globals.TickCount() - grenades[index][2]) * globals.TickInterval();
Builder:AddBarBottom( 1 - (DeltaT/1.65) )
found = true;
break;
end
end
if found == false and globals.TickCount() > updatetick then
local gMatrix = {Builder:GetEntity():GetIndex(), globals.TickCount()};
table.insert(grenades, gMatrix);
end
end
end

function DrawingHook() 
for indexF,valueF in pairs(entities.FindByClass("CInferno")) do
local found = false;
for indexT,valueT in pairs(grenades) do
if valueT[1] == valueF:GetIndex() then
x, y = client.WorldToScreen( valueF:GetAbsOrigin() )
local mollysize = 25;
if x ~= nil and y ~= nil then
draw.Color(0, 0, 0, 255);
draw.RoundedRectFill( x - mollysize, y, x + mollysize, y + 4 );
draw.Color(227, 227, 227, 255);
local math = (((globals.TickCount() - valueT[2]) * ((-1) - 1))
/ ( (valueT[2] + 7 / globals.TickInterval()) - valueT[2])) + 1
draw.RoundedRectFill( x - mollysize, y, x + mollysize * math, y + 4 )
draw.Color(255, 255, 255, 255);
draw.RoundedRect( x - mollysize, y, x + mollysize, y + 4) 
local w,h = draw.GetTextSize( "MOLLY" ) 
draw.Text(x - w/2, y - h * 1.25 , "MOLLY");
draw.TextShadow(x - w/2, y - h * 1.25 , "MOLLY");
end 
found = true;
break;
end
end

if found == false and globals.TickCount() > updatetick then
local gMatrix = {valueF:GetIndex(), globals.TickCount()};
table.insert(grenades, gMatrix);
end
end
end

-- Grenade timers by Nyanpasu! (- Luiz)

client.AllowListener("round_start");
client.AllowListener("inferno_expire");
client.AllowListener("inferno_extinguish");
client.AllowListener("molotov_detonate");
client.AllowListener("hegrenade_detonate");
client.AllowListener("flashbang_detonate");
callbacks.Register("FireGameEvent", "EventHookG", EventHook);
callbacks.Register( "Draw", "DrawingHookG", DrawingHook );
callbacks.Register( "DrawESP", "ESPHookG", ESPHook );

drawBar = false
firstTime = 0
timeSincePlant = 0
fill = 0
fps = "fps";
count = 0;
last = globals.RealTime();
r = 0
g = 0
b = 0
stoplagwithcolourpicking = 1
configs = {}
v = {}

fontTable =
{
  [0] = "Arial",
  [1] = "Arial Bold",
  [2] = "Calibri",
  [3] = "Comic Sans MS",
  [4] = "Tahoma"
}

function colourBcDumbass(value)

    if value == 0 then
    
        r = 255
        g = 0
        b = 0
    
    end
    
    if value == 1 then
    
        r = 0
        g = 255
        b = 0
    
    end
    
    if value == 2 then
    
        r = 0
        g = 0
        b = 255
    
    end
    
    if value == 3 then
    
        r = 255
        g = 255
        b = 255
    
    end
    
    if value == 4 then
    
        r = 0
        g = 0
        b = 0
    
    end

end

otheroptions = gui.Reference("VISUALS", "OTHER", "Options")
groupoptions = gui.Groupbox(otheroptions, "vers' bomb timer", 0, 270, 210, 270)

enabled = gui.Checkbox( groupoptions, "enabled", "Enabled", true ) 

textoptions = gui.Groupbox(groupoptions, "text options", 0, 30, 180, 200)

timerText = gui.Checkbox( textoptions, "timerText" , "Enable Timer Text", true )
fontSize = gui.Slider( textoptions, "fontSize" , "Font Size", 15, 1, 50 )

fontName = gui.Combobox( textoptions, "fontName", "Font", 

    "Arial", 
    "Arial (Bold)", 
    "Calibri", 
    "Comic Sans", 
    "Tahoma"
    
)

fontColour = gui.Combobox( textoptions, "fontColour", "Colour", 

    "Red", 
    "Green", 
    "Blue", 
    "White", 
    "Black"

)

timerEnabled = 1
timerTextEnabled = 1
fontSizeLua = 22.4
fontUsed = 1
fontColourUsed = 3

function openCfg()


    local Configuration = file.Open("BombTimeCFG", "r")
    
    if Configuration==nil then
    
        timerEnabled = 1
        timerTextEnabled = 1
        fontSizeLua = 22.4
        fontUsed = 1
        fontColourUsed = 3
    
        importCfg()
                
    else
        
        a = GetFirstLine(Configuration:Read())
        
        Configuration:Close()
    
    end
    
end

function boolCheck(input)

    if input == true then
    
        return 1
    
    else
    
        return 0
        
    end
    
end

function saveCfg()

    timerEnabled = enabled:GetValue()
    timerTextEnabled = timerText:GetValue()
    fontSizeLua = math.floor(fontSize:GetValue())
    fontUsed = fontName:GetValue()
    fontColourUsed = fontColour:GetValue()
    
    local ConfigFile = file.Open( "BombTimeCFG", "w" )
    
    ConfigFile:Write(boolCheck(timerEnabled).."\n")
    ConfigFile:Write(boolCheck(timerTextEnabled).."\n")
    ConfigFile:Write(fontSizeLua..  "\n")
    ConfigFile:Write(fontUsed.."\n")
    ConfigFile:Write(fontColourUsed.."\n")
    
    ConfigFile:Close()

end



function importCfg()


    gui.SetValue( "enabled", timerEnabled)
    gui.SetValue( "timerText", timerTextEnabled)
    gui.SetValue( "fontSize", fontSizeLua )
    gui.SetValue( "fontName", fontUsed )
    gui.SetValue( "fontColour", fontColourUsed )
    
    saveCfg()
    
end

function GetFirstLine(input)

    local count = 0
    
    for i in string.gmatch(input, "%S+") do
        
        v[count] = i
        
        count = count + 1
        
    end
    
    timerEnabled = icbatomakenicecodeanymore(v[0])
    timerTextEnabled = icbatomakenicecodeanymore(v[1])
    fontSizeLua = v[2]
    fontUsed = v[3]
    fontColourUsed = v[4]
    
    v = 0
        
    importCfg()
    
end

local frametimes = {}
local fps_prev = 0;

local function accumulate_fps()
   local ft = globals.AbsoluteFrameTime()
   if ft > 0 then
       table.insert(frametimes, 1, ft)
   end

   local count = #frametimes
   if count == 0 then
       return 0
   end

   local i, accum = 0, 0
   while accum < 0.5 do
       i = i + 1
       accum = accum + frametimes[i]
       if i >= count then
           break
       end
   end
   accum = accum / i
   while i < count do
       i = i + 1
       table.remove(frametimes)
   end
 
   local fps = 1 / accum
   local rt = globals.RealTime()
   if math.abs(fps - fps_prev) > 4 or rt - last_update_time > 2 then
       fps_prev = fps
       last_update_time = rt
   else
       fps = fps_prev
   end
 
   return math.floor(fps + 0.5)
end

function bomb(event)
        
    if event:GetName() == "bomb_planted" then
        
        drawBar = true
        plantedTime = globals.CurTime()
        
    end
    
    if event:GetName() == "round_end" then
    
        drawBar = false
        firstTime = 0
        fill = 0
        stoplagwithcolourpicking = 1
        saveCfg()
        
    end
    
end

function drawTimer()

    if drawBar == true then
        
        if enabled:GetValue() == true then 
        
            local c4 = entities.FindByClass("CPlantedC4")            
            c4time = math.floor(c4[1]:GetProp("m_flTimerLength"))
            local screenX, screenY = draw.GetScreenSize()
            
            local godownby = (screenY / c4time) / accumulate_fps()
            
            draw.Color(0,255,0,255)
            draw.FilledRect(0, fill, 10, screenY) 

            draw.Color(0,0,0,100)
            draw.FilledRect( 0, 0, 10, screenY )
                    
            if timerText:GetValue() == true then
            
                if stoplagwithcolourpicking == 1 then
            
                    colourBcDumbass(fontColour:GetValue())
                    stoplagwithcolourpicking = 0
                
                end
                
                draw.Color(r,g,b)
                draw.SetFont(     draw.CreateFont( fontTable[fontName:GetValue()], math.floor(fontSize:GetValue()) , 150) )
                draw.TextShadow( 2, fill, math.floor((plantedTime - globals.CurTime()) + c4time))

            end        
                        
            fill = fill + godownby
            
        end
        
    end
        
end

client.AllowListener( 'bomb_planted' );
client.AllowListener( 'round_end' );

callbacks.Register( 'FireGameEvent', 'BombTimerPlantEvent', bomb );
callbacks.Register( 'Draw', 'BombTimerDraw', drawTimer );

openCfg()



